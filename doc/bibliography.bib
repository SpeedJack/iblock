@article{whitepaper,
	title = {Bitcoin: A Peer-to-Peer Electronic Cash System},
	author = {Nakamoto, Satoshi},
	url = {https://bitcoin.org/bitcoin.pdf},
	journal = {Cryptography Mailing List at https://metzdowd.com},
	year = {2008},
	month = {10},
	numpages = {9},
	note = {The Bitcoin white paper},
	abstract={A purely peer-to-peer version of electronic cash would allow online payments to be sent directly from one party to another without going through a financial institution. Digital signatures provide part of the solution, but the main benefits are lost if a trusted third party is still required to prevent double-spending. We propose a solution to the double-spending problem using a peer-to-peer network. The network timestamps transactions by hashing them into an ongoing chain of hash-based proof-of-work, forming a record that cannot be changed without redoing the proof-of-work. The longest chain not only serves as proof of the sequence of events witnessed, but proof that it came from the largest pool of CPU power. As long as a majority of CPU power is controlled by nodes that are not cooperating to attack the network, they'll generate the longest chain and outpace attackers. The network itself requires minimal structure. Messages are broadcast on a best effort basis, and nodes can leave and rejoin the network at will, accepting the longest proof-of-work chain as proof of what happened while they were gone.},
}

@inproceedings{intermittent-selfish-mining,
	author = {Negy, Kevin Alarc{\'o}n and Rizun, Peter R. and Sirer, Emin G{\"u}n},
	editor = {Bonneau, Joseph and Heninger, Nadia},
	title = {Selfish Mining Re-Examined},
	booktitle = {Financial Cryptography and Data Security},
	series = {Lecture Notes in Computer Science},
	volume = {12059},
	year = {2020},
	publisher = {Springer International Publishing},
	institution = {Cornell University},
	address = {Cham},
	pages = {61--78},
	abstract = {Six years after the introduction of selfish mining, its counterintuitive findings continue to create confusion. In this paper, we comprehensively address one particular source of misunderstandings, related to difficulty adjustments. We first present a novel, modified selfish mining strategy, called intermittent selfish mining, that, perplexingly, is more profitable than honest mining even when the attacker performs no selfish mining after a difficulty adjustment. Simulations show that even in the most conservative scenario ({\$}{\$}{\backslash}gamma =0{\$}{\$}), an intermittent selfish miner above 37{\%} hash power earns more coins per time unit than their fair share. We then broadly examine the profitability of selfish mining under several difficulty adjustment algorithms (DAAs) used in popular cryptocurrencies. We present a taxonomy of popular difficulty adjustment algorithms, quantify the effects of algorithmic choices on hash fluctuations, and show how resistant different DAA families are to selfish mining.},
	isbn = {978-3-030-51280-4},
	doi = {10.1007/978-3-030-51280-4_5},
}

@article{selfish-mining,
	title = {Majority is not Enough: Bitcoin Mining is Vulnerable}, 
	author = {Eyal, Ittay and Sirer, Emin G\"{u}n},
	journal = {Computer Science: Cryptography and Security},
	year = {2013},
	eprint = {1311.0243},
	institution = {Cornell University},
	archivePrefix = {arXiv},
	primaryClass = {cs.CR},
	doi = {10.48550/arXiv.1311.0243},
	numpages = {17},
}

@inproceedings{omnetpp,
	author = {Varga, Andr\'{a}s and Hornig, Rudolf},
	title = {An overview of the OMNeT++ simulation environment},
	year = {2008},
	isbn = {9789639799202},
	publisher = {ICST (Institute for Computer Sciences, Social-Informatics and Telecommunications Engineering)},
	address = {Brussels, BEL},
	abstract = {The OMNeT++ discrete event simulation environment has been publicly available since 1997. It has been created with the simulation of communication networks, multiprocessors and other distributed systems in mind as application area, but instead of building a specialized simulator, OMNeT++ was designed to be as general as possible. Since then, the idea has proven to work, and OMNeT++ has been used in numerous domains from queuing network simulations to wireless and ad-hoc network simulations, from business process simulation to peer-to-peer network, optical switch and storage area network simulations. This paper presents an overview of the OMNeT++ framework, recent challenges brought about by the growing amount and complexity of third party simulation models, and the solutions we introduce in the next major revision of the simulation framework.},
	booktitle = {Proceedings of the 1st International Conference on Simulation Tools and Techniques for Communications, Networks and Systems \& Workshops},
	articleno = {60},
	numpages = {10},
	keywords = {telecommunications, simulation tools, performance analysis, network simulation, integrated development environment, hierarchical, discrete simulation, computer systems},
	location = {Marseille, France},
	series = {Simutools '08},
	url = {https://dl.acm.org/doi/10.5555/1416222.1416290},
}

@online{omnetpp-website,
	shorthand = {OPP},
	title = {OMNeT++ Discrete Event Simulator},
	url = {https://omnetpp.org},
	urldate = {2024-11-08},
}

@manual{omnetpp-simulation-manual,
	shorthand = {OPPSM},
	title = {OMNeT++ Simulation Manual},
	version = {6.x},
	author = {Varga, Andr{\'a}s and others},
	organization = {OpenSim Ltd.},
	year = {2023},
	url = {https://doc.omnetpp.org/omnetpp/manual/},
	urldate = {2024-11-07},
}

@inproceedings{valgrind,
	author = {Nethercote, Nicholas and Seward, Julian},
	title = {Valgrind: a framework for heavyweight dynamic binary instrumentation},
	year = {2007},
	month = {06},
	isbn = {9781595936332},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://valgrind.org},
	urldate = {2024-11-07},
	doi = {10.1145/1250734.1250746},
	abstract = {Dynamic binary instrumentation (DBI) frameworks make it easy to build dynamic binary analysis (DBA) tools such as checkers and profilers. Much of the focus on DBI frameworks has been on performance; little attention has been paid to their capabilities. As a result, we believe the potential of DBI has not been fully exploited.In this paper we describe Valgrind, a DBI framework designed for building heavyweight DBA tools. We focus on its unique support for shadow values-a powerful but previously little-studied and difficult-to-implement DBA technique, which requires a tool to shadow every register and memory value with another value that describes it. This support accounts for several crucial design features that distinguish Valgrind from other DBI frameworks. Because of these features, lightweight tools built with Valgrind run comparatively slowly, but Valgrind can be used to build more interesting, heavyweight tools that are difficult or impossible to build with other DBI frameworks such as Pin and DynamoRIO.},
	booktitle = {Proceedings of the 28th ACM SIGPLAN Conference on Programming Language Design and Implementation},
	pages = {89--100},
	numpages = {12},
	keywords = {Memcheck, Valgrind, dynamic binary analysis, dynamic binary instrumentation, shadow values},
	location = {San Diego, California, USA},
	series = {PLDI '07},
}

@inproceedings{memcheck,
	author = {Seward, Julian and Nethercote, Nicholas},
	title = {Using Valgrind to detect undefined value errors with bit-precision},
	year = {2005},
	month = {04},
	booktitle = {2005 USENIX Annual Technical Conference (USENIX ATC 05)},
	address = {Anaheim, California, USA},
	url = {https://www.usenix.org/conference/2005-usenix-annual-technical-conference/using-valgrind-detect-undefined-value-errors-bit},
	publisher = {USENIX Association},
	series = {ATEC '05},
	abstract = {We present Memcheck, a tool that has been implemented with the dynamic binary instrumentation framework Valgrind. Memcheck detects a wide range of memory errors in programs as they run. This paper focuses on one kind of error that Memcheck detects: undefined value errors. Such errors are common, and often cause bugs that are hard to find in programs written in languages such as C, C++ and Fortran. Memcheck's definedness checking improves on that of previous tools by being accurate to the level of individual bits. This accuracy gives Memcheck a low false positive and false negative rate.The definedness checking involves shadowing every bit of data in registers and memory with a second bit that indicates if the bit has a defined value. Every value-creating operation is instrumented with a shadow operation that propagates shadow bits appropriately. Memcheck uses these shadow bits to detect uses of undefined values that could adversely affect a program's behaviour.Under Memcheck, programs typically run 20-30 times slower than normal. This is fast enough to use with large programs. Memcheck finds many errors in real programs, and has been used during the past two years by thousands of programmers on a wide range of systems, including OpenOffice, Mozilla, Opera, KDE, GNOME, MySQL, Perl, Samba, The GIMP, and Unreal Tournament.},
}

@inproceedings{callgrind,
	author = {Weidendorfer, Josef},
	editor = {Resch, Michael and Keller, Rainer and Himmler, Valentin and Krammer, Bettina and Schulz, Alexander},
	title = {Sequential Performance Analysis with Callgrind and KCachegrind},
	booktitle = {Tools for High Performance Computing},
	year = {2008},
	publisher = {Springer Berlin Heidelberg},
	address = {Berlin, Heidelberg},
	pages = {93--113},
	abstract = {This chapter presents the suite of tools Callgrind and KCachegrind. The first is an execution driven cache simulator, which outputs profile information on cache events, as well as the dynamic call graph of the execution, attributed with call counts and inclusive costs. KCachegrind is a visualization tool tailored at browsing the results gathered by Callgrind. After some introduction to sequential performance analysis and related tools, the tool suite is presented, followed by typical use cases. Finally, future developments are discussed.},
	isbn = {978-3-540-68564-7},
	doi = {10.1007/978-3-540-68564-7_7},
}

@article{blocksim,
	author = {Alharby, Maher and van Moorsel, Aad},
	title = {BlockSim: An Extensible Simulation Tool for Blockchain Systems},
	journal = {Frontiers in Blockchain},
	volume = {3},
	year = {2020},
	url = {https://www.frontiersin.org/journals/blockchain/articles/10.3389/fbloc.2020.00028},
	doi = {10.3389/fbloc.2020.00028},
	issn = {2624-7852},
	abstract = {Both in the design and deployment of blockchain solutions many performance-impacting configuration choices need to be made. We introduce BlockSim, a framework and software tool to build and simulate discrete-event dynamic systems models for blockchain systems. BlockSim is designed to support the analysis of a large variety of blockchains and blockchain deployments as well as a wide set of analysis questions. At the core of BlockSim is a Base Model, which contains the main model constructs common across various blockchain systems organized in three abstraction layers (network, consensus, and incentives layer). The Base Model is usable for a wide variety of blockchain systems and can be extended easily to include system or deployment particulars. The BlockSim software tool provides a simulator that implements the Base Model in Python. The paper describes the Base Model, the simulator implementation, and the application of BlockSim to Bitcoin, Ethereum and other consensus algorithms. We validate BlockSim simulation results by comparison with performance results from actual systems and from other studies in the literature. We close the paper by a BlockSim simulation study of the impact of uncle blocks rewards on mining decentralization, for a variety of blockchain configurations.},
}

@online{bip141,
	shorthand = {BIP141},
	author = {Lombrozo, Eric and Lau, Johnson and Wuille, Pieter},
	title = {Segregated Witness (Consensus layer)},
	url = {https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki},
	year = {2015},
	month = {12},
	note = {Bitcoin Improvement Proposal 141},
}

@online{bip144,
	shorthand = {BIP144},
	author = {Lombrozo, Eric and Wuille, Pieter},
	title = {Segregated Witness (Peer Services)},
	url = {https://github.com/bitcoin/bips/blob/master/bip-0144.mediawiki},
	year = {2016},
	month = {01},
	note = {Bitcoin Improvement Proposal 144},
}

@online{learnmeabitcoin,
	title = {Learn Me A Bitcoin},
	url = {https://learnmeabitcoin.com},
	author = {Walker, Greg},
	urldate = {2024-11-07},
	year = {2024},
	note = {Frequently updated document},
}

@online{bitcoin-dev,
	shorthand = {BDev},
	title = {Bitcoin Developer Guides},
	url = {https://developer.bitcoin.org/devguide/index.html},
	organization = {Bitcoin Project},
	urldate = {2024-11-08},
}

@online{bitcoin-core,
	shorthand = {BCore},
	title = {Bitcoin Core},
	url = {https://bitcoincore.org},
	urldate = {2024-11-08},
	note = {Reference implementation of the Bitcoin protocol},
}

@online{bitcoin-wiki,
	shorthand = {Wiki},
	title = {Bitcoin Wiki},
	url = {https://en.bitcoin.it/wiki/Main_Page},
	urldate = {2024-11-08},
}

@online{btcwiki-scalability,
	shorthand = {WikiScal},
	title = {Scalability --- Bitcoin Wiki},
	url = {https://en.bitcoin.it/wiki/Scalability},
	urldate = {2024-11-07},
}

@online{blockchaincom-tps,
	shorthand = {BCTPS},
	author = {Blockchain.com},
	title = {Blockchain.com | Charts --- Transaction Rate Per Second},
	url = {https://www.blockchain.com/explorer/charts/transactions-per-second},
	note = {Online, real-time chart},
	urldate = {2024-11-07},
}
